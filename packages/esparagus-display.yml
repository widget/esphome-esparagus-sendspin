# Enables display with a few pages
# starting - shows friendly_name
# clock - shows time
# off - blank
# play - scrolls title and artist
#
# Something in the display lambda is very expensive and really slows down
# the main loop.  To combat that, this runs the CPU faster
defaults:
  font_small: 14
  display_model: SH1106 128x64

api:
  on_client_connected: 
    then:
      - display.page.show: page_clock

esp32:
  # override CPU freq
  cpu_frequency: 240MHz

logger:
  logs:
    # don't log missing glyph errors
    font: ERROR

spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23
  # miso not used in this protocol
  id: spi_bus_display

time:
  - platform: homeassistant
    id: esptime

font:
  - file: 'gfonts://Material+Symbols+Outlined'
    id: icons_small
    size: ${font_small}
    glyphs:
      - "\ue019" # album
      - "\ue01a" # artist
      - "\U000fffd8" # music notes
  - file:
      type: gfonts
      family: Ubuntu # TODO try 'Jersey 10 Charted'
      weight: regular
    id: text_small
    size: ${font_small}
    glyphsets: 
      - GF_Latin_Core # European alphabets too
  # For the clock page
  - file:
      type: gfonts
      family: Roboto
      weight: regular
    id: text_big
    size: 40
    glyphs: [' ', ':', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

text_sensor:
  # These don't have names, they don't need sharing back to HA (MA knows)
  - platform: sendspin
    type: title
    id: ss_title
    on_value:
      - globals.set:
          id: title_length
          value: '0'

  - platform: sendspin
    type: artist
    id: ss_artist
    on_value:
      - globals.set:
          id: artist_length
          value: '0'

  - platform: sendspin
    type: album
    id: ss_album
    on_value:
      - globals.set:
          id: album_length
          value: '0'

# We're caching pixel lengths of strings here, as it's unclear
# how expensive those string calculations are every screen raster
globals:
  - id: title_length
    type: int
    restore_value: no
    initial_value: '0'
  - id: artist_length
    type: int
    restore_value: no
    initial_value: '0'
  - id: album_length
    type: int
    restore_value: no
    initial_value: '0'

# Use this switch in HA to e.g. turn the screen off
# when everyone's out, or at bedtime
switch:
  - platform: template
    name: "Screen"
    id: switch_screen
    optimistic: true
    restore_mode: ALWAYS_ON
    turn_on_action:
      - if:
          condition:
            api.connected:
          then:
            - if:
                condition:
                  media_player.is_idle: ${speaker_id}
                then:
                  - display.page.show: page_clock
                else:
                  - display.page.show: page_play
    turn_off_action:
      - display.page.show: page_off

media_player:
  - platform: speaker_source
    id: !extend "${speaker_id}"

    # Go back to the speaker_source and add automations
    # to select the audio_playing page, or the clock

    on_play:
      - display.page.show: page_play
      - switch.template.publish:
          id: switch_screen
          state: ON

    on_idle:
      - display.page.show: page_clock

display:
  - platform: ssd1306_spi
    model: ${display_model}
    id: spi_display
    spi_id: spi_bus_display
    cs_pin: 
      number: ${display_cs}
      ignore_strapping_warning: true
    dc_pin: ${display_dc}
    reset_pin: ${display_reset}

    # These two set how much time the ESP32 is running the display
    # which takes time away from playing audio!
    update_interval: 250ms
    data_rate: 10MHz # T_cycle min is 100ns

    pages:
      - id: page_startup
        lambda: |-
          it.printf(it.get_width() / 2, 20, 
                    id(text_small), TextAlign::CENTER, "${friendly_name}");
          it.printf(it.get_width() / 2, 40, 
                    id(text_small), TextAlign::CENTER, "connecting...");

      # Selected by api.on_connection
      - id: page_clock
        lambda: |-
          // display clock
          auto hours = id(esptime).now().hour;
          auto minutes = id(esptime).now().minute;
          auto seconds = id(esptime).now().second;
          auto dot = seconds % 2 == 0 ? " " : ":";

          it.printf(it.get_width() / 2, 
                    it.get_height() / 2, 
                    id(text_big), 
                    TextAlign::CENTER, 
                    "%d%s%02d", hours, dot, minutes);
          
      - id: page_off
        lambda: return;

      # Selected by the speaker on_play
      - id: page_play
        lambda: |-
          const int PADDING_LEFT = 18, PADDING_RIGHT = 28;
          const int LINE_HEIGHTS[] = {10, 32, 54};
          int x1, y1, new_h, new_w, 
              title_width_offset = PADDING_LEFT, 
              artist_width_offset = PADDING_LEFT,
              album_width_offset = PADDING_LEFT;
          bool increment = false;
          static int iteration = 0;

          // Draw some icons
          it.print(0, LINE_HEIGHTS[0], 
                    id(icons_small), 
                    TextAlign::CENTER_LEFT, 
                    "\U000fffd8"); // music icon
          it.print(0, LINE_HEIGHTS[1], 
                  id(icons_small), 
                  TextAlign::CENTER_LEFT, 
                  "\ue01a"); // artist icon
          it.print(0, LINE_HEIGHTS[2], 
                  id(icons_small), 
                  TextAlign::CENTER_LEFT, 
                  "\ue019"); // album icon

          // Don't scroll over the icons
          it.start_clipping( Rect(PADDING_LEFT, 
                                  0, 
                                  it.get_width(), 
                                  it.get_height()));

          if (id(title_length) == 0) {
            it.get_text_bounds(0, 0, 
                              id(ss_title).state.c_str(), 
                              id(text_small), 
                              TextAlign::TOP_LEFT, 
                              &x1, &y1, &new_w, &new_h);
            id(title_length) = new_w;
          }

          if (id(title_length) + PADDING_LEFT >= it.get_width()) {
            auto missing_artist_text = id(title_length) - it.get_width();
            increment = true;
            title_width_offset = PADDING_LEFT - (iteration % (missing_artist_text + PADDING_RIGHT));
          }
          it.print(title_width_offset, LINE_HEIGHTS[0], 
                    id(text_small), 
                    TextAlign::CENTER_LEFT, 
                    id(ss_title).state.c_str());

          // Do this again for the artist
          if (id(artist_length) == 0) {
            it.get_text_bounds(0, 0, 
                              id(ss_artist).state.c_str(), 
                              id(text_small), 
                              TextAlign::TOP_LEFT, 
                              &x1, &y1, &new_w, &new_h);
            id(artist_length) = new_w;
          }

          if (id(artist_length) + PADDING_LEFT >= it.get_width()) {
            auto missing_title_text = id(artist_length) - it.get_width();
            increment = true;
            artist_width_offset = PADDING_LEFT - (iteration % (missing_title_text + PADDING_RIGHT));
          }
          it.print(artist_width_offset, LINE_HEIGHTS[1], 
                  id(text_small), 
                  TextAlign::CENTER_LEFT, 
                  id(ss_artist).state.c_str());

          // And the album
          if (id(album_length) == 0) {
            it.get_text_bounds(0, 0, 
                              id(ss_album).state.c_str(), 
                              id(text_small), 
                              TextAlign::TOP_LEFT, 
                              &x1, &y1, &new_w, &new_h);
            id(album_length) = new_w;
          }

          if (id(album_length) + PADDING_LEFT >= it.get_width()) {
            auto missing_album_text = id(album_length) - it.get_width();
            increment = true;
            album_width_offset = PADDING_LEFT - (iteration % (missing_album_text + PADDING_RIGHT));
          }
          it.print(album_width_offset, LINE_HEIGHTS[2], 
                  id(text_small), 
                  TextAlign::CENTER_LEFT, 
                  id(ss_album).state.c_str());

          it.end_clipping();

          if (increment) {
            iteration++;
          }
